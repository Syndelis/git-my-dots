#!/bin/bash
# ------------------------------------------------------------------------------
# AUXILIARY FUNCTIONS
# ------------------------------------------------------------------------------

PRE_EXISTING=""
fetch_pre_existing() {
    PRE_EXISTING=$(cd $1 && git ls-files | sed -e 's/^/A  /')
}

check_pre_existing() {
    # maybe?
}

# ------------------------------------------------------------------------------
# GLOBALS & SUBCOMMANDS
# ------------------------------------------------------------------------------

VERSION="1.0"
BASE="\033"
CLEAN="$BASE[m"
BLACK="$BASE[30m"
RED="$BASE[31m"
GREEN="$BASE[32m"
YELLOW="$BASE[33m"
PURPLE="$BASE[34m"
PINK="$BASE[35m"
CYAN="$BASE[36m"

# dotfile help ---------------------------------------------
dot_help() {

printf "Usage: dotfiler [-v | -h] [--help | --version] <command> [--source=.] [--target=..] [--force]

Available Commands:
    install\t\tInstalls dotfiler on [sources]'s Git repository
    remove\t\tUninstalls dotfiler [sources]'s Git repository

    sync\t\tSyncs the [source]'s Git repository directory
    \t\t--force: Deletes existing files and re-creates them

    help\t\tPrints this message
    version\t\tTells you this program's version ($VERSION, btw)\n"
}

# dotfile install ------------------------------------------
dot_install() {
    
    if [ -e "$1/.git" ]; then

        fetch_pre_existing $1
        dot_sync

        if ! [ -z "${PRE_EXISTING// }" ]; then
            printf "$YELLOW[Question]$CLEAN Do you want to sync the existing dotfiles [Y/n]?  \b"

            while true; do
                read answer

                case "$answer" in
                    "n" | "N") break ;;
                    "" | "y" | "Y")
                        echo "echo $$pre_existing | .git/hooks/pre-commit"
                        break
                        ;;

                    *)
                        printf "$YELLOW[?]$CLEAN Option not recognized. [Y/n]?  \b"

                esac
            done
        fi

        # cat "$TARGET" > pre-commit-dir
        printf "$GREEN[Success]$CLEAN Installed$PINK dotfiler$CLEAN at$CYAN $1 $CLEAN\n"

    else
        printf "$RED[Error]$CLEAN Couldn't find a$PINK git$CLEAN repository at$CYAN $1 $CLEAN\n"
    fi

}

# dotfile remove -------------------------------------------
dot_remove() {
    echo "Remove $1"
}

# dotfile sync ---------------------------------------------
dot_sync() {
    
    if [ -z "${PRE_EXISTING// }" ]; then
        fetch_pre_existing $1
    fi

    echo "$PRE_EXISTING"

    # TODO: Check for --force
}


# ------------------------------------------------------------------------------
# MAIN CODE
# ------------------------------------------------------------------------------

OPTS=$(getopt -o hv -l version,help,source:,target: -n "dotfiler" -- "$@")

HAS_HELP=false
HAS_VERSION=false

IS_FORCED=false
IS_SYMBOLIC=false
NAMED_ARGUMENT=""
SUBCOMMAND=""
SOURCE="."
TARGET=".."

for opt in $OPTS
do
    case "$opt" in

        -v | --version) HAS_VERSION=true                ;;
        -h | --help)    HAS_HELP=true                   ;;

        --force)        IS_FORCED=true                  ;;
        --source)       NAMED_ARGUMENT="SOURCE"         ;;
        --target)       NAMED_ARGUMENT="TARGET"         ;;
        --)             NAMED_ARGUMENT="SUBCOMMAND"     ;;

        *)
            val=$(echo $opt | tr -d "'")
            case "$NAMED_ARGUMENT" in
                "SOURCE")       SOURCE="$val"           ;;
                "TARGET")       TARGET="$val"           ;;
                "SUBCOMMAND")   SUBCOMMAND="$val"       ;;

                *)              HAS_HELP=true           ;;
            esac

    esac
done

if $HAS_VERSION; then
    echo "dotfiler version $VERSION"

elif $HAS_HELP || [ -z $SUBCOMMAND ]; then
    dot_help

else
    dot_${SUBCOMMAND} $(readlink -f -- $SOURCE) $(readlink -f -- $TARGET)

fi